"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _NodeJsBundler_instances, _NodeJsBundler_getNodeModulesJs, _NodeJsBundler_copyDependencies, _NodeJsBundler_copyNonJsFiles, _NodeJsBundler_bundleJavascriptCode, _NodeJsBundler_deleteTypeModuleFromPackageJson;
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeJsBundler = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const webpack_node_externals_1 = __importDefault(require("webpack-node-externals"));
const file_1 = require("../../utils/file");
const bundler_interface_1 = require("../bundler.interface");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lambdaHander_1 = require("../../utils/lambdaHander");
const loglevel_1 = __importDefault(require("loglevel"));
const node_polyfill_webpack_plugin_1 = __importDefault(require("node-polyfill-webpack-plugin"));
const webpack_1 = require("../../utils/webpack");
const logging_1 = require("../../utils/logging");
class NodeJsBundler {
    constructor() {
        _NodeJsBundler_instances.add(this);
    }
    bundle(input) {
        return __awaiter(this, void 0, void 0, function* () {
            const mode = (input.extra ? input.extra["mode"] : undefined) || "production";
            const tmpFolder = (input.extra ? input.extra["tmpFolder"] : undefined) || undefined;
            if (mode === "development" && !tmpFolder) {
                throw new Error("tmpFolder is required in development mode.");
            }
            const temporaryFolder = mode === "production" ? yield (0, file_1.createTemporaryFolder)() : tmpFolder;
            // 1. Run webpack to get dependenciesInfo and the packed file
            logging_1.debugLogger.debug(`[NodeJSBundler] Get the list of node modules and bundling the javascript code for file ${input.path}.`);
            const [dependenciesInfo, _] = yield Promise.all([
                __classPrivateFieldGet(this, _NodeJsBundler_instances, "m", _NodeJsBundler_getNodeModulesJs).call(this, input.path, mode),
                __classPrivateFieldGet(this, _NodeJsBundler_instances, "m", _NodeJsBundler_bundleJavascriptCode).call(this, input.configuration.path, temporaryFolder, mode),
                mode === "development" ? __classPrivateFieldGet(this, _NodeJsBundler_instances, "m", _NodeJsBundler_copyDependencies).call(this, null, temporaryFolder, mode) : Promise.resolve()
            ]);
            logging_1.debugLogger.debug(`[NodeJSBundler] Copy non js files and node_modules for file ${input.path}.`);
            // 2. Copy non js files and node_modules and write index.js file
            yield Promise.all([
                __classPrivateFieldGet(this, _NodeJsBundler_instances, "m", _NodeJsBundler_copyNonJsFiles).call(this, temporaryFolder),
                mode === "production" ? __classPrivateFieldGet(this, _NodeJsBundler_instances, "m", _NodeJsBundler_copyDependencies).call(this, dependenciesInfo, temporaryFolder, mode) : Promise.resolve(),
                (0, file_1.writeToFile)(temporaryFolder, "index.js", (0, lambdaHander_1.lambdaHandler)(`"${input.configuration.name}"`))
            ]);
            // 3. Delete type: module from package.json
            yield __classPrivateFieldGet(this, _NodeJsBundler_instances, "m", _NodeJsBundler_deleteTypeModuleFromPackageJson).call(this, temporaryFolder);
            return Object.assign(Object.assign({}, input), { path: temporaryFolder, extra: {
                    dependenciesInfo
                } });
        });
    }
}
exports.NodeJsBundler = NodeJsBundler;
_NodeJsBundler_instances = new WeakSet(), _NodeJsBundler_getNodeModulesJs = function _NodeJsBundler_getNodeModulesJs(filePath, mode) {
    return __awaiter(this, void 0, void 0, function* () {
        if (mode === "development") {
            return null;
        }
        const { name } = (0, file_1.getFileDetails)(filePath);
        const outputFile = `${name}-processed.js`;
        const temporaryFolder = yield (0, file_1.createTemporaryFolder)();
        const dependencies = [];
        yield (0, webpack_1.bundle)("./" + filePath, mode, [], undefined, [new node_polyfill_webpack_plugin_1.default(), new bundler_interface_1.AccessDependenciesPlugin(dependencies)], temporaryFolder, outputFile, {
            conditionNames: ["require"]
        }
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        );
        const dependenciesInfo = dependencies.map((dependency) => {
            const relativePath = dependency.split("node_modules" + path_1.default.sep)[1];
            const dependencyName = relativePath === null || relativePath === void 0 ? void 0 : relativePath.split(path_1.default.sep)[0];
            const dependencyPath = dependency.split("node_modules" + path_1.default.sep)[0] +
                "node_modules" +
                path_1.default.sep +
                dependencyName;
            return {
                name: dependencyName,
                path: dependencyPath
            };
        });
        // remove duplicates from dependenciesInfo by name
        const uniqueDependenciesInfo = dependenciesInfo.filter((v, i, a) => a.findIndex((t) => t.name === v.name) === i);
        return uniqueDependenciesInfo;
    });
}, _NodeJsBundler_copyDependencies = function _NodeJsBundler_copyDependencies(dependenciesInfo, tempFolderPath, mode) {
    return __awaiter(this, void 0, void 0, function* () {
        const nodeModulesPath = path_1.default.join(tempFolderPath, "node_modules");
        if (mode === "development") {
            // copy node_modules folder to tmp folder if node_modules folder does not exist
            if (!fs_1.default.existsSync(nodeModulesPath) && fs_1.default.existsSync(path_1.default.join(process.cwd(), "node_modules"))) {
                yield fs_extra_1.default.copy(path_1.default.join(process.cwd(), "node_modules"), nodeModulesPath);
            }
            return;
        }
        // copy all dependencies to node_modules folder
        yield Promise.all(dependenciesInfo.map((dependency) => {
            const dependencyPath = path_1.default.join(nodeModulesPath, dependency.name);
            return fs_extra_1.default.copy(dependency.path, dependencyPath);
        }));
    });
}, _NodeJsBundler_copyNonJsFiles = function _NodeJsBundler_copyNonJsFiles(tempFolderPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const allNonJsFilesPaths = (yield (0, file_1.getAllFilesFromCurrentPath)()).filter((file) => {
            // filter js files, node_modules and folders
            return (file.extension !== ".js" &&
                !file.path.includes("node_modules") &&
                !fs_1.default.lstatSync(file.path).isDirectory());
        });
        // iterare over all non js files and copy them to tmp folder
        yield Promise.all(allNonJsFilesPaths.map((filePath) => {
            // get folders array
            const folders = filePath.path.split(path_1.default.sep);
            // remove file name from folders array
            folders.pop();
            // create folder structure in tmp folder
            const folderPath = path_1.default.join(tempFolderPath, ...folders);
            if (!fs_1.default.existsSync(folderPath)) {
                fs_1.default.mkdirSync(folderPath, { recursive: true });
            }
            // copy file to tmp folder
            const fileDestinationPath = path_1.default.join(tempFolderPath, filePath.path);
            return fs_1.default.promises.copyFile(filePath.path, fileDestinationPath);
        }));
    });
}, _NodeJsBundler_bundleJavascriptCode = function _NodeJsBundler_bundleJavascriptCode(filePath, tempFolderPath, mode) {
    return __awaiter(this, void 0, void 0, function* () {
        const outputFile = `module.js`;
        // delete module.js file if it exists
        if (fs_1.default.existsSync(path_1.default.join(tempFolderPath, outputFile))) {
            fs_1.default.unlinkSync(path_1.default.join(tempFolderPath, outputFile));
        }
        // eslint-disable-next-line no-async-promise-executor
        const output = yield (0, webpack_1.bundle)("./" + filePath, mode, [(0, webpack_node_externals_1.default)()], {
            rules: [
                {
                    test: /\.html$/,
                    loader: "dumb-loader",
                    exclude: /really\.html/
                }
            ]
        }, undefined, tempFolderPath, outputFile);
        if (output != undefined) {
            output.forEach((error) => {
                var _a, _b, _c, _d;
                // log error red
                loglevel_1.default.error("\x1b[31m", "Syntax error:");
                if ((_a = error.moduleIdentifier) === null || _a === void 0 ? void 0 : _a.includes("|")) {
                    loglevel_1.default.info("\x1b[37m", "file: " +
                        ((_b = error.moduleIdentifier) === null || _b === void 0 ? void 0 : _b.split("|")[1]) +
                        ":" +
                        ((_c = error.loc) === null || _c === void 0 ? void 0 : _c.split(":")[0]));
                }
                else {
                    loglevel_1.default.info("file: " + error.moduleIdentifier + ":" + ((_d = error.loc) === null || _d === void 0 ? void 0 : _d.split(":")[0]));
                }
                // get first line of error
                const firstLine = error.message.split("\n")[0];
                loglevel_1.default.info(firstLine);
                //get message line that contains '>' first character
                const messageLine = error.message
                    .split("\n")
                    .filter((line) => line.startsWith(">") || line.startsWith("|"))
                    .join("\n");
                if (messageLine) {
                    loglevel_1.default.info(messageLine);
                }
            });
            throw "Compilation failed";
        }
    });
}, _NodeJsBundler_deleteTypeModuleFromPackageJson = function _NodeJsBundler_deleteTypeModuleFromPackageJson(tempFolderPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const packageJsonPath = path_1.default.join(tempFolderPath, "package.json");
        // check if package.json file exists
        if (!fs_1.default.existsSync(packageJsonPath)) {
            return;
        }
        // read package.json file
        const packageJson = JSON.parse((yield (0, file_1.readUTF8File)(packageJsonPath)) || "{}");
        // delete type module from package.json
        delete packageJson.type;
        // write package.json file
        yield (0, file_1.writeToFile)(tempFolderPath, "package.json", JSON.stringify(packageJson, null, 2));
    });
};
