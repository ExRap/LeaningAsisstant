"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _NodeTsBundler_instances, _NodeTsBundler_generateTsconfigJson, _NodeTsBundler_getNodeModulesTs, _NodeTsBundler_copyDependencies, _NodeTsBundler_copyNonTsFiles, _NodeTsBundler_bundleTypescriptCode, _NodeTsBundler_deleteTypeModuleFromPackageJson;
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeTsBundler = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const util_1 = __importDefault(require("util"));
const webpack_node_externals_1 = __importDefault(require("webpack-node-externals"));
const file_1 = require("../../utils/file");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lambdaHander_1 = require("../../utils/lambdaHander");
const configs_1 = require("../../utils/configs");
const loglevel_1 = __importDefault(require("loglevel"));
const node_polyfill_webpack_plugin_1 = __importDefault(require("node-polyfill-webpack-plugin"));
const bundler_interface_1 = require("../bundler.interface");
const webpack_1 = require("../../utils/webpack");
const logging_1 = require("../../utils/logging");
// eslint-disable-next-line @typescript-eslint/no-var-requires
const exec = util_1.default.promisify(require("child_process").exec);
class NodeTsBundler {
    constructor() {
        _NodeTsBundler_instances.add(this);
    }
    bundle(input) {
        return __awaiter(this, void 0, void 0, function* () {
            const mode = (input.extra ? input.extra["mode"] : undefined) || "production";
            const tmpFolder = (input.extra ? input.extra["tmpFolder"] : undefined) || undefined;
            if (mode === "development" && !tmpFolder) {
                throw new Error("tmpFolder is required in development mode.");
            }
            const temporaryFolder = mode === "production" ? yield (0, file_1.createTemporaryFolder)() : tmpFolder;
            // 1. Create auxiliary folder and copy the entire project
            __classPrivateFieldGet(this, _NodeTsBundler_instances, "m", _NodeTsBundler_generateTsconfigJson).call(this);
            logging_1.debugLogger.debug(`[NodeTSBundler] Get the list of node modules and bundling the javascript code for file ${input.path}.`);
            // 2. Run webpack to get dependenciesInfo and the packed file
            const [dependenciesInfo, _] = yield Promise.all([
                __classPrivateFieldGet(this, _NodeTsBundler_instances, "m", _NodeTsBundler_getNodeModulesTs).call(this, input.path, mode),
                __classPrivateFieldGet(this, _NodeTsBundler_instances, "m", _NodeTsBundler_bundleTypescriptCode).call(this, input.configuration.path, temporaryFolder, mode),
                mode === "development" ? __classPrivateFieldGet(this, _NodeTsBundler_instances, "m", _NodeTsBundler_copyDependencies).call(this, null, temporaryFolder, mode) : Promise.resolve()
            ]);
            logging_1.debugLogger.debug(`[NodeTSBundler] Copy non TS files and node_modules for file ${input.path}.`);
            // 2. Copy non js files and node_modules and write index.js file
            yield Promise.all([
                __classPrivateFieldGet(this, _NodeTsBundler_instances, "m", _NodeTsBundler_copyNonTsFiles).call(this, temporaryFolder),
                mode === "production" ? __classPrivateFieldGet(this, _NodeTsBundler_instances, "m", _NodeTsBundler_copyDependencies).call(this, dependenciesInfo, temporaryFolder, mode) : Promise.resolve(),
                (0, file_1.writeToFile)(temporaryFolder, "index.js", (0, lambdaHander_1.lambdaHandler)(`"${input.configuration.name}"`))
            ]);
            // 3. Delete type: module from package.json
            yield __classPrivateFieldGet(this, _NodeTsBundler_instances, "m", _NodeTsBundler_deleteTypeModuleFromPackageJson).call(this, temporaryFolder);
            return Object.assign(Object.assign({}, input), { path: temporaryFolder, extra: {
                    dependenciesInfo
                } });
        });
    }
}
exports.NodeTsBundler = NodeTsBundler;
_NodeTsBundler_instances = new WeakSet(), _NodeTsBundler_generateTsconfigJson = function _NodeTsBundler_generateTsconfigJson() {
    if (fs_1.default.existsSync("tsconfig.json")) {
        return;
    }
    else {
        console.log("No tsconfig.json file found. We will create one...");
        configs_1.tsconfig.compilerOptions.rootDir = ".";
        configs_1.tsconfig.compilerOptions.outDir = path_1.default.join(".", "build");
        configs_1.tsconfig.include = [path_1.default.join(".", "**/*")];
        (0, file_1.writeToFile)(process.cwd(), "tsconfig.json", JSON.stringify(configs_1.tsconfig, null, 4));
        // writeToFile(process.cwd(), "package.json", packagejson);
    }
}, _NodeTsBundler_getNodeModulesTs = function _NodeTsBundler_getNodeModulesTs(filePath, mode) {
    return __awaiter(this, void 0, void 0, function* () {
        if (mode === "development") {
            return null;
        }
        const dependencies = [];
        const { name } = (0, file_1.getFileDetails)(filePath);
        const outputFile = `${name}-processed.js`;
        const temporaryFolder = yield (0, file_1.createTemporaryFolder)();
        const module = {
            rules: [
                {
                    test: /\.tsx?$/,
                    use: [
                        {
                            loader: "ts-loader",
                            options: {
                                configFile: "tsconfig.json",
                                onlyCompileBundledFiles: true
                            }
                        }
                    ],
                    exclude: /really\.html/
                }
            ]
        };
        const plugins = [
            new node_polyfill_webpack_plugin_1.default(),
            new bundler_interface_1.AccessDependenciesPlugin(dependencies)
        ];
        const resolve = { extensions: [".tsx", ".ts", ".js"] };
        const resolveLoader = {
            modules: [path_1.default.resolve(__dirname, "../../../", "node_modules")],
            conditionNames: ["require"]
        };
        yield (0, webpack_1.bundle)("./" + filePath, mode, [], module, plugins, temporaryFolder, outputFile, resolve, resolveLoader);
        const dependenciesInfo = dependencies.map((dependency) => {
            const relativePath = dependency.split("node_modules" + path_1.default.sep)[1];
            const dependencyName = relativePath === null || relativePath === void 0 ? void 0 : relativePath.split(path_1.default.sep)[0];
            const dependencyPath = dependency.split("node_modules" + path_1.default.sep)[0] +
                "node_modules" +
                path_1.default.sep +
                dependencyName;
            //dependencyPath.replace(folder, cwd);
            return {
                name: dependencyName,
                path: dependencyPath
            };
        });
        // remove duplicates from dependenciesInfo by name
        const uniqueDependenciesInfo = dependenciesInfo.filter((v, i, a) => a.findIndex((t) => t.name === v.name) === i);
        return uniqueDependenciesInfo;
    });
}, _NodeTsBundler_copyDependencies = function _NodeTsBundler_copyDependencies(dependenciesInfo, tempFolderPath, mode) {
    return __awaiter(this, void 0, void 0, function* () {
        const nodeModulesPath = path_1.default.join(tempFolderPath, "node_modules");
        if (mode === "development") {
            // copy node_modules folder to tmp folder if node_modules folder does not exist
            if (!fs_1.default.existsSync(nodeModulesPath) && fs_1.default.existsSync(path_1.default.join(process.cwd(), "node_modules"))) {
                yield fs_extra_1.default.copy(path_1.default.join(process.cwd(), "node_modules"), nodeModulesPath);
            }
            return;
        }
        // copy all dependencies to node_modules folder
        yield Promise.all(dependenciesInfo.map((dependency) => {
            const dependencyPath = path_1.default.join(nodeModulesPath, dependency.name);
            return fs_extra_1.default.copy(dependency.path, dependencyPath);
        }));
    });
}, _NodeTsBundler_copyNonTsFiles = function _NodeTsBundler_copyNonTsFiles(tempFolderPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const allNonJsFilesPaths = (yield (0, file_1.getAllFilesFromCurrentPath)()).filter((file) => {
            // filter js files, node_modules and folders
            return (file.extension !== ".ts" &&
                file.extension !== ".js" &&
                file.extension !== ".tsx" &&
                file.extension !== ".jsx" &&
                !file.path.includes("node_modules") &&
                !fs_1.default.lstatSync(file.path).isDirectory());
        });
        // iterare over all non js files and copy them to tmp folder
        yield Promise.all(allNonJsFilesPaths.map((filePath) => {
            // get folders array
            const folders = filePath.path.split(path_1.default.sep);
            // remove file name from folders array
            folders.pop();
            // create folder structure in tmp folder
            const folderPath = path_1.default.join(tempFolderPath, ...folders);
            if (!fs_1.default.existsSync(folderPath)) {
                fs_1.default.mkdirSync(folderPath, { recursive: true });
            }
            // copy file to tmp folder
            const fileDestinationPath = path_1.default.join(tempFolderPath, filePath.path);
            return fs_1.default.promises.copyFile(filePath.path, fileDestinationPath);
        }));
    });
}, _NodeTsBundler_bundleTypescriptCode = function _NodeTsBundler_bundleTypescriptCode(filePath, tempFolderPath, mode) {
    return __awaiter(this, void 0, void 0, function* () {
        // eslint-disable-next-line no-async-promise-executor
        const module = {
            rules: [
                {
                    test: /\.tsx?$/,
                    use: [
                        {
                            loader: "ts-loader",
                            options: {
                                configFile: "tsconfig.json",
                                onlyCompileBundledFiles: true
                            }
                        }
                    ],
                    exclude: /really\.html/
                }
            ]
        };
        const resolve = { extensions: [".tsx", ".ts", ".js"] };
        const resolveLoader = {
            modules: [path_1.default.resolve(__dirname, "../../../", "node_modules")]
        };
        const outputFile = `module.js`;
        // delete module.js file if it exists
        if (fs_1.default.existsSync(path_1.default.join(tempFolderPath, outputFile))) {
            fs_1.default.unlinkSync(path_1.default.join(tempFolderPath, outputFile));
        }
        const output = yield (0, webpack_1.bundle)("./" + filePath, mode, [(0, webpack_node_externals_1.default)()], module, undefined, tempFolderPath, outputFile, resolve, resolveLoader);
        if (output != undefined) {
            output.forEach((error) => {
                var _a, _b, _c, _d, _e;
                // log error red
                loglevel_1.default.error("\x1b[31m", "Syntax error:");
                if ((_a = error.details) === null || _a === void 0 ? void 0 : _a.includes("ts-loader-default")) {
                    loglevel_1.default.info(error.message);
                }
                else {
                    if ((_b = error.moduleIdentifier) === null || _b === void 0 ? void 0 : _b.includes("|")) {
                        loglevel_1.default.info("\x1b[37m", "file: " +
                            ((_c = error.moduleIdentifier) === null || _c === void 0 ? void 0 : _c.split("|")[1]) +
                            ":" +
                            ((_d = error.loc) === null || _d === void 0 ? void 0 : _d.split(":")[0]));
                    }
                    else {
                        loglevel_1.default.info("file: " + error.moduleIdentifier + ":" + ((_e = error.loc) === null || _e === void 0 ? void 0 : _e.split(":")[0]));
                    }
                    // get first line of error
                    const firstLine = error.message.split("\n")[0];
                    loglevel_1.default.info(firstLine);
                    //get message line that contains '>' first character
                    const messageLine = error.message
                        .split("\n")
                        .filter((line) => line.startsWith(">") || line.startsWith("|"))
                        .join("\n");
                    if (messageLine) {
                        loglevel_1.default.info(messageLine);
                    }
                }
            });
            throw "Compilation failed";
        }
        //await writeToFile(tempFolderPath, "index.js", lambdaHandler);
    });
}, _NodeTsBundler_deleteTypeModuleFromPackageJson = function _NodeTsBundler_deleteTypeModuleFromPackageJson(tempFolderPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const packageJsonPath = path_1.default.join(tempFolderPath, "package.json");
        // check if package.json file exists
        if (!fs_1.default.existsSync(packageJsonPath)) {
            return;
        }
        // read package.json file
        const packageJson = JSON.parse((yield (0, file_1.readUTF8File)(packageJsonPath)) || "{}");
        // delete type module from package.json
        delete packageJson.type;
        // write package.json file
        yield (0, file_1.writeToFile)(tempFolderPath, "package.json", JSON.stringify(packageJson, null, 2));
    });
};
