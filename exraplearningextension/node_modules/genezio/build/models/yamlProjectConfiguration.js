"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.YamlProjectConfiguration = exports.YamlClassConfiguration = exports.YamlMethodConfiguration = exports.YamlSdkConfiguration = exports.Language = exports.JsRuntime = exports.TriggerType = void 0;
const path_1 = __importDefault(require("path"));
const yaml_1 = __importDefault(require("yaml"));
const file_1 = require("../utils/file");
const configs_1 = require("../utils/configs");
const cron_validator_1 = require("cron-validator");
var TriggerType;
(function (TriggerType) {
    TriggerType["jsonrpc"] = "jsonrpc";
    TriggerType["cron"] = "cron";
    TriggerType["http"] = "http";
})(TriggerType = exports.TriggerType || (exports.TriggerType = {}));
var JsRuntime;
(function (JsRuntime) {
    JsRuntime["browser"] = "browser";
    JsRuntime["node"] = "node";
})(JsRuntime = exports.JsRuntime || (exports.JsRuntime = {}));
var Language;
(function (Language) {
    Language["js"] = "js";
    Language["ts"] = "ts";
    Language["swift"] = "swift";
})(Language = exports.Language || (exports.Language = {}));
class YamlSdkConfiguration {
    constructor(language, runtime, path) {
        this.language = language;
        this.options = {};
        this.options.runtime = runtime || null;
        this.path = path;
    }
}
exports.YamlSdkConfiguration = YamlSdkConfiguration;
class YamlMethodConfiguration {
    constructor(name, type, cronString) {
        this.name = name;
        this.type = type !== null && type !== void 0 ? type : TriggerType.jsonrpc;
        this.cronString = cronString;
    }
    static create(methodConfigurationYaml, classType) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!methodConfigurationYaml.name) {
                throw new Error("Missing method name in configuration file.");
            }
            if (methodConfigurationYaml.type &&
                !TriggerType[methodConfigurationYaml.type]) {
                throw new Error("The method's type is incorrect.");
            }
            let type = classType;
            if (methodConfigurationYaml.type) {
                type =
                    TriggerType[methodConfigurationYaml.type];
            }
            if (type == TriggerType.cron && !methodConfigurationYaml.cronString) {
                throw new Error("The cron method is missing a cron string property.");
            }
            // Checkcron string format
            if (type == TriggerType.cron) {
                if (!(0, cron_validator_1.isValidCron)(methodConfigurationYaml.cronString)) {
                    throw new Error("The cron string is not valid. Check https://crontab.guru/ for more information.");
                }
                const cronParts = methodConfigurationYaml.cronString.split(" ");
                if (cronParts[2] != "*" && cronParts[4] != "*") {
                    throw new Error("The cron string is not valid. The day of the month and day of the week cannot be specified at the same time.");
                }
            }
            return new YamlMethodConfiguration(methodConfigurationYaml.name, type, methodConfigurationYaml.cronString);
        });
    }
}
exports.YamlMethodConfiguration = YamlMethodConfiguration;
class YamlClassConfiguration {
    constructor(path, type, language, methods) {
        this.path = path;
        this.type = type;
        this.methods = methods;
        this.language = language;
    }
    getMethodType(methodName) {
        const method = this.methods.find((method) => method.name === methodName);
        if (!method) {
            return this.type;
        }
        if (method && method.type) {
            return method.type;
        }
        return TriggerType.jsonrpc;
    }
    static create(classConfigurationYaml) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!classConfigurationYaml.path) {
                throw new Error("Path is missing from class.");
            }
            if (classConfigurationYaml.type &&
                !TriggerType[classConfigurationYaml.type]) {
                const triggerTypes = Object.keys(TriggerType).join(", ");
                throw new Error("Specified class type for " + classConfigurationYaml.path + " is incorrect. Accepted values: " + triggerTypes + ".");
            }
            let triggerType = TriggerType.jsonrpc;
            if (classConfigurationYaml.type) {
                triggerType =
                    TriggerType[classConfigurationYaml.type];
            }
            const unparsedMethods = classConfigurationYaml.methods || [];
            const methods = yield Promise.all(unparsedMethods.map((method) => YamlMethodConfiguration.create(method, triggerType)));
            const language = path_1.default.parse(classConfigurationYaml.path).ext;
            return new YamlClassConfiguration(classConfigurationYaml.path, triggerType, language, methods);
        });
    }
}
exports.YamlClassConfiguration = YamlClassConfiguration;
/**
 * This class represents the model for the YAML configuration file.
 */
class YamlProjectConfiguration {
    constructor(name, region, sdk, cloudProvider, classes, frontend = undefined) {
        this.name = name;
        this.region = region;
        this.sdk = sdk;
        this.cloudProvider = cloudProvider;
        this.classes = classes;
        this.frontend = frontend;
    }
    static create(configurationFileContent) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!configurationFileContent.name) {
                throw new Error("The name property is missing from the configuration file.");
            }
            const nameRegex = new RegExp("^[a-zA-Z][-a-zA-Z0-9]*$");
            if (!nameRegex.test(configurationFileContent.name)) {
                throw new Error("The method name is not valid. It must be [a-zA-Z][-a-zA-Z0-9]*");
            }
            if (!configurationFileContent.sdk) {
                throw new Error("The sdk property is missing from the configuration file.");
            }
            if (!configurationFileContent.sdk.path) {
                throw new Error("The sdk.path property is missing from the configuration file.");
            }
            const language = configurationFileContent.sdk.language;
            if (!language) {
                throw new Error("The sdk.language property is missing.");
            }
            if (!Language[language]) {
                throw new Error("The sdk.language property is invalid.");
            }
            if (Language[language] == Language.js ||
                Language[language] == Language.ts) {
                if (!configurationFileContent.sdk.options) {
                    throw new Error("The sdk.options property is missing from the configuration file.");
                }
                if (!configurationFileContent.sdk.options.runtime) {
                    throw new Error("The sdk.options.runtime property is missing from the configuration file.");
                }
                if (!JsRuntime[configurationFileContent.sdk.options.runtime]) {
                    throw new Error("The sdk.options.runtime property is invalid.");
                }
            }
            const jsRuntime = configurationFileContent.sdk.options
                ? JsRuntime[configurationFileContent.sdk.options
                    .runtime]
                : null;
            const sdk = new YamlSdkConfiguration(Language[configurationFileContent.sdk.language], jsRuntime, configurationFileContent.sdk.path);
            const unparsedClasses = configurationFileContent.classes;
            if (!unparsedClasses) {
                throw new Error("The configuration file should contain at least one class.");
            }
            const classes = yield Promise.all(unparsedClasses.map((c) => YamlClassConfiguration.create(c)));
            if (configurationFileContent.region) {
                if (!configs_1.regions.includes(configurationFileContent.region)) {
                    throw new Error(`The region is invalid. Please use a valid region.\n Region list: ${configs_1.regions}`);
                }
            }
            if (configurationFileContent.frontend) {
                if (!configurationFileContent.frontend.path) {
                    throw new Error("The frontend.path value is not set.");
                }
            }
            return new YamlProjectConfiguration(configurationFileContent.name, configurationFileContent.region || "us-east-1", sdk, configurationFileContent.cloudProvider || "aws", classes, configurationFileContent.frontend);
        });
    }
    getMethodType(path, methodName) {
        const classElement = this.classes.find((classElement) => {
            return classElement.path === path;
        });
        return classElement === null || classElement === void 0 ? void 0 : classElement.getMethodType(methodName);
    }
    addClass(classPath, type, methods) {
        const language = path_1.default.parse(classPath).ext;
        this.classes.push(new YamlClassConfiguration(classPath, type, language, methods));
    }
    writeToFile(path = "./genezio.yaml") {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const classes = [];
            const content = {
                name: this.name,
                region: this.region,
                cloudProvider: this.cloudProvider ? this.cloudProvider : undefined,
                sdk: {
                    language: this.sdk.language,
                    options: {
                        runtime: (_a = this.sdk.options) === null || _a === void 0 ? void 0 : _a.runtime
                    },
                    path: this.sdk.path
                },
                frontend: this.frontend ? {
                    path: (_b = this.frontend) === null || _b === void 0 ? void 0 : _b.path,
                    subdomain: (_c = this.frontend) === null || _c === void 0 ? void 0 : _c.subdomain
                } : undefined,
                classes: this.classes.map((c) => ({
                    path: c.path,
                    type: c.type,
                    methods: c.methods.map((m) => ({
                        name: m.name,
                        type: m.type,
                        cronString: m.cronString
                    }))
                }))
            };
            this.classes.forEach((c) => {
                classes.push();
            });
            const fileDetails = (0, file_1.getFileDetails)(path);
            const yamlString = yaml_1.default.stringify(content);
            yield (0, file_1.writeToFile)(fileDetails.path, fileDetails.filename, yamlString).catch((error) => {
                console.error(error.toString());
            });
        });
    }
    addSubdomain(subdomain) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this.frontend = {
                path: ((_a = this.frontend) === null || _a === void 0 ? void 0 : _a.path) || "./frontend/build",
                subdomain: subdomain
            };
            yield this.writeToFile();
        });
    }
}
exports.YamlProjectConfiguration = YamlProjectConfiguration;
