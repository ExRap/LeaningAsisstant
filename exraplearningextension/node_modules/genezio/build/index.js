#! /usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const commander_1 = require("commander");
const commands_1 = require("./commands");
const logging_1 = require("./utils/logging");
const strings_1 = require("./utils/strings");
const process_1 = require("process");
const variables_1 = require("./variables");
const localEnvironment_1 = require("./localEnvironment");
const configuration_1 = require("./utils/configuration");
const loglevel_1 = __importDefault(require("loglevel"));
const accounts_1 = require("./utils/accounts");
const loglevel_plugin_prefix_1 = __importDefault(require("loglevel-plugin-prefix"));
// eslint-disable-next-line @typescript-eslint/no-var-requires
const pjson = require("../package.json");
const program = new commander_1.Command();
loglevel_1.default.setDefaultLevel("INFO");
loglevel_plugin_prefix_1.default.reg(loglevel_1.default);
loglevel_plugin_prefix_1.default.apply(loglevel_1.default.getLogger("debuggingLogger"), {
    template: "[%t] %l:",
    levelFormatter(level) {
        return level.toUpperCase();
    },
    nameFormatter(name) {
        return name || "global";
    },
    timestampFormatter(date) {
        return date.toISOString();
    }
});
if (variables_1.ENABLE_DEBUG_LOGS_BY_DEFAULT) {
    (0, logging_1.setDebuggingLoggerLogLevel)("debug");
}
program
    .name("genezio")
    .usage("[command]")
    .description("CLI tool to interact with the genezio infrastructure!")
    .exitOverride((err) => {
    if (err.code === "commander.help" || err.code === "commander.version" || err.code === "commander.helpDisplayed") {
        (0, process_1.exit)(0);
    }
    else {
        console.log(`Type 'genezio --help' or 'genezio [command] --help'.`);
    }
})
    .addHelpText("afterAll", `\nUse 'genezio [command] --help' for more information about a command.`)
    .version(pjson.version);
program
    .command("init")
    .option("--logLevel <logLevel>", "Show debug logs to console. Possible levels: trace/debug/info/warn/error.")
    .description("Create the initial configuration file for a genezio project.")
    .action((options) => __awaiter(void 0, void 0, void 0, function* () {
    (0, logging_1.setDebuggingLoggerLogLevel)(options.logLevel);
    try {
        yield (0, commands_1.init)();
    }
    catch (error) {
        loglevel_1.default.error(error.message);
    }
}));
program
    .command("login")
    .argument("[accessToken]", "Personal access token.")
    .option("--logLevel <logLevel>", "Show debug logs to console. Possible levels: trace/debug/info/warn/error.")
    .description("Authenticate with genezio platform to deploy your code.")
    .action((accessToken = "", options) => __awaiter(void 0, void 0, void 0, function* () {
    (0, logging_1.setDebuggingLoggerLogLevel)(options.logLevel);
    loglevel_1.default.info(strings_1.asciiCapybara);
    yield (0, commands_1.handleLogin)(accessToken).catch((error) => {
        loglevel_1.default.error(error.message);
        (0, process_1.exit)(1);
    });
}));
program
    .command("deploy")
    .option("--frontend", "Deploy the frontend application.")
    .option("--logLevel <logLevel>", "Show debug logs to console. Possible levels: trace/debug/info/warn/error.")
    .description("Deploy your project to the genezio infrastructure. Use --frontend to deploy the frontend application.")
    .action((options) => __awaiter(void 0, void 0, void 0, function* () {
    (0, logging_1.setDebuggingLoggerLogLevel)(options.logLevel);
    // check if user is logged in
    const authToken = yield (0, accounts_1.getAuthToken)();
    if (!authToken) {
        loglevel_1.default.error(strings_1.GENEZIO_NOT_AUTH_ERROR_MSG);
        (0, process_1.exit)(1);
    }
    if (options.frontend) {
        loglevel_1.default.info("Deploying your frontend to genezio infrastructure...");
        let url;
        try {
            url = yield (0, commands_1.deployFrontend)();
        }
        catch (error) {
            loglevel_1.default.error(error.message);
            (0, process_1.exit)(1);
        }
        loglevel_1.default.info("\x1b[36m%s\x1b[0m", `Frontend successfully deployed at ${url}.`);
        (0, process_1.exit)(0);
    }
    yield (0, commands_1.deployClasses)()
        .catch((error) => {
        var _a, _b, _c, _d, _e, _f, _g;
        switch ((_a = error.response) === null || _a === void 0 ? void 0 : _a.status) {
            case 401:
                loglevel_1.default.error(strings_1.GENEZIO_NOT_AUTH_ERROR_MSG);
                break;
            case 500:
                loglevel_1.default.error(error.message);
                if ((_b = error.response) === null || _b === void 0 ? void 0 : _b.data) {
                    const data = (_c = error.response) === null || _c === void 0 ? void 0 : _c.data;
                    loglevel_1.default.error((_d = data.error) === null || _d === void 0 ? void 0 : _d.message);
                }
                break;
            case 400:
                loglevel_1.default.error(error.message);
                if ((_e = error.response) === null || _e === void 0 ? void 0 : _e.data) {
                    const data = (_f = error.response) === null || _f === void 0 ? void 0 : _f.data;
                    loglevel_1.default.error((_g = data.error) === null || _g === void 0 ? void 0 : _g.message);
                }
                break;
            default:
                if (error.message) {
                    loglevel_1.default.error(error.message);
                }
                break;
        }
        (0, process_1.exit)(1);
    });
}));
program
    .command("addClass")
    .option("--logLevel <logLevel>", "Show debug logs to console. Possible levels: trace/debug/info/warn/error.")
    .argument("<classPath>", "Path of the class you want to add.")
    .argument("[<classType>]", "The type of the class you want to add. [http, jsonrpc, cron]")
    .description("Add a new class to the 'genezio.yaml' file.")
    .action((classPath, classType, options) => __awaiter(void 0, void 0, void 0, function* () {
    (0, logging_1.setDebuggingLoggerLogLevel)(options.logLevel);
    yield (0, commands_1.addNewClass)(classPath, classType).catch((error) => {
        loglevel_1.default.error(error.message);
        (0, process_1.exit)(1);
    });
}));
program
    .command("local")
    .option("--logLevel <logLevel>", "Show debug logs to console.")
    .option("-p, --port <port>", "Set the port your local server will be running on.", String(variables_1.PORT_LOCAL_ENVIRONMENT))
    .description("Run a local environment for your functions.")
    .action((options) => __awaiter(void 0, void 0, void 0, function* () {
    (0, logging_1.setDebuggingLoggerLogLevel)(options.logLevel);
    const authToken = yield (0, accounts_1.getAuthToken)();
    if (!authToken) {
        loglevel_1.default.error(strings_1.GENEZIO_NOT_AUTH_ERROR_MSG);
        (0, process_1.exit)(1);
    }
    let classesInfo = [];
    try {
        // eslint-disable-next-line no-constant-condition
        while (true) {
            const projectConfiguration = yield (0, configuration_1.getProjectConfiguration)();
            let server = undefined;
            let handlers = undefined;
            let astSummary = undefined;
            let cronHandlers = [];
            yield (0, localEnvironment_1.startLocalTesting)(classesInfo, options)
                .catch((error) => __awaiter(void 0, void 0, void 0, function* () {
                if (error.message === "Unauthorized" || error.message.includes("401")) {
                    loglevel_1.default.error(strings_1.GENEZIO_NOT_AUTH_ERROR_MSG);
                    (0, process_1.exit)(1);
                }
                else if (error.message.includes("No classes found")) {
                    loglevel_1.default.error(error.message);
                    (0, process_1.exit)(1);
                }
                loglevel_1.default.error("\x1b[31m%s\x1b[0m", `Error while preparing for local environment:\n${error.message}`);
                loglevel_1.default.error(`Fix the errors and genezio local will restart automatically. Waiting for changes...`);
                yield (0, localEnvironment_1.listenForChanges)(null, null, null).catch((error) => {
                    loglevel_1.default.error(error.message);
                    (0, process_1.exit)(1);
                });
                return null;
            }))
                .then((responseStartLocal) => __awaiter(void 0, void 0, void 0, function* () {
                if (responseStartLocal === null) {
                    return;
                }
                handlers = responseStartLocal.handlers;
                astSummary = responseStartLocal.astSummary;
                classesInfo = responseStartLocal.classesInfo;
                if (handlers != undefined) {
                    loglevel_1.default.info("\x1b[32m%s\x1b[0m", `Test your code at ${variables_1.LOCAL_TEST_INTERFACE_URL}?port=${options.port}`);
                    const startServerOutput = yield (0, localEnvironment_1.startServer)(classesInfo, handlers, astSummary, Number(options.port));
                    server = startServerOutput.server;
                    cronHandlers = startServerOutput.cronHandlers;
                    server.on("error", (error) => {
                        if (error.code === "EADDRINUSE") {
                            loglevel_1.default.error(`The port ${error.port} is already in use. Please use a different port by specifying --port <port> to start your local server.`);
                        }
                        else {
                            loglevel_1.default.error(error.message);
                        }
                        (0, process_1.exit)(1);
                    });
                }
                else {
                    loglevel_1.default.info("\x1b[36m%s\x1b[0m", "Listening for changes...");
                }
                yield (0, localEnvironment_1.listenForChanges)(projectConfiguration.sdk.path, server, cronHandlers).catch((error) => {
                    loglevel_1.default.error(error.message);
                    (0, process_1.exit)(1);
                });
            }));
        }
    }
    catch (error) {
        loglevel_1.default.error(error.message);
        (0, process_1.exit)(1);
    }
}));
program
    .command("logout")
    .option("--logLevel <logLevel>", "Show debug logs to console. Possible levels: trace/debug/info/warn/error.")
    .description("Logout from Genezio platform.")
    .action((options) => __awaiter(void 0, void 0, void 0, function* () {
    (0, logging_1.setDebuggingLoggerLogLevel)(options.logLevel);
    yield (0, accounts_1.removeAuthToken)()
        .then(() => {
        loglevel_1.default.info("You are now logged out!");
    })
        .catch((error) => {
        if (error.code === "ENOENT") {
            loglevel_1.default.error("You were already logged out.");
        }
        else {
            loglevel_1.default.error("Logout failed!");
        }
        (0, process_1.exit)(1);
    });
}));
program
    .command("account")
    .option("--logLevel <logLevel>", "Show debug logs to console. Possible levels: trace/debug/info/warn/error.")
    .description("Display information about the current account.")
    .action((options) => __awaiter(void 0, void 0, void 0, function* () {
    (0, logging_1.setDebuggingLoggerLogLevel)(options.logLevel);
    const authToken = yield (0, accounts_1.getAuthToken)();
    if (!authToken) {
        loglevel_1.default.error(strings_1.GENEZIO_NOT_AUTH_ERROR_MSG);
        (0, process_1.exit)(1);
    }
    else {
        loglevel_1.default.info("You are logged in.");
    }
}));
program
    .command("ls")
    .argument("[identifier]", "Name or ID of the project you want to display.")
    .option("--logLevel <logLevel>", "Show debug logs to console. Possible levels: trace/debug/info/warn/error.")
    .option("-l, --long-listed", "List more details for each project")
    .description("Display details of your projects. You can view them all at once or display a particular one by providing its name or ID.")
    .action((identifier = "", options) => __awaiter(void 0, void 0, void 0, function* () {
    (0, logging_1.setDebuggingLoggerLogLevel)(options.logLevel);
    // check if user is logged in
    const authToken = yield (0, accounts_1.getAuthToken)();
    if (!authToken) {
        loglevel_1.default.error(strings_1.GENEZIO_NOT_AUTH_ERROR_MSG);
        (0, process_1.exit)(1);
    }
    yield (0, commands_1.lsHandler)(identifier, options.longListed).catch((error) => {
        var _a;
        if (((_a = error.response) === null || _a === void 0 ? void 0 : _a.status) === 401) {
            loglevel_1.default.error(strings_1.GENEZIO_NOT_AUTH_ERROR_MSG);
        }
        else {
            loglevel_1.default.error(error.message);
        }
        (0, process_1.exit)(1);
    });
}));
program
    .command("delete")
    .argument("[projectId]", "ID of the project you want to delete.")
    .option("--logLevel <logLevel>", "Show debug logs to console. Possible levels: trace/debug/info/warn/error.")
    .option("-f, --force", "Skip confirmation prompt for deletion.", false)
    .description("Delete the project described by the provided ID. If no ID is provided, lists all the projects and IDs.")
    .action((projectId = "", options) => __awaiter(void 0, void 0, void 0, function* () {
    (0, logging_1.setDebuggingLoggerLogLevel)(options.logLevel);
    // check if user is logged in
    const authToken = yield (0, accounts_1.getAuthToken)();
    if (!authToken) {
        loglevel_1.default.error(strings_1.GENEZIO_NOT_AUTH_ERROR_MSG);
        (0, process_1.exit)(1);
    }
    const result = yield (0, commands_1.deleteProjectHandler)(projectId, options.force).catch((error) => {
        var _a;
        if (((_a = error.response) === null || _a === void 0 ? void 0 : _a.status) == 401) {
            loglevel_1.default.error(strings_1.GENEZIO_NOT_AUTH_ERROR_MSG);
        }
        else {
            loglevel_1.default.error(error.message);
        }
        (0, process_1.exit)(1);
    });
    if (result) {
        loglevel_1.default.info("Your project has been deleted");
    }
}));
program
    .command("generateSdk")
    .option("--logLevel <logLevel>", "Show debug logs to console. Possible levels: trace/debug/info/warn/error.")
    .option("-lang, --language <language>", "Language of the SDK to generate.")
    .option("-p, --path <path>", "Path to the directory where the SDK will be generated.")
    .description("Generate an SDK corresponding to a deployed project.")
    .action((options) => __awaiter(void 0, void 0, void 0, function* () {
    (0, logging_1.setDebuggingLoggerLogLevel)(options.logLevel);
    // check if user is logged in
    const authToken = yield (0, accounts_1.getAuthToken)();
    if (!authToken) {
        loglevel_1.default.error(strings_1.GENEZIO_NOT_AUTH_ERROR_MSG);
        (0, process_1.exit)(1);
    }
    const language = options.language;
    const sdkPath = options.path;
    if (!language) {
        loglevel_1.default.error("Please specify a language for the SDK to generate using --language <language>. Please use one of the following: ts, js, swift.");
        (0, process_1.exit)(1);
    }
    // check if language is supported
    if (language !== "ts" && language !== "js" && language !== "swift") {
        loglevel_1.default.error("The language you specified is not supported. Please use one of the following: ts, js, swift.");
        (0, process_1.exit)(1);
    }
    if (!sdkPath) {
        loglevel_1.default.error("Please specify a path for the SDK to generate using --path <path>.");
        (0, process_1.exit)(1);
    }
    yield (0, commands_1.generateSdkHandler)(language, sdkPath).catch((error) => {
        var _a;
        if (((_a = error.response) === null || _a === void 0 ? void 0 : _a.status) == 401) {
            loglevel_1.default.error(strings_1.GENEZIO_NOT_AUTH_ERROR_MSG);
        }
        else {
            loglevel_1.default.error(error.message);
        }
        (0, process_1.exit)(1);
    });
    console.log("Your SDK has been generated successfully in " + sdkPath + "");
}));
program.parse();
