"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareForLocalEnvironment = exports.startServer = exports.startLocalTesting = exports.startCronHandlers = exports.prepareCronHandlers = exports.stopCronJobs = exports.listenForChanges = exports.handleResponseforHttp = exports.handleResponseForJsonRpc = exports.getEventObjectFromRequest = void 0;
const path_1 = __importDefault(require("path"));
const chokidar_1 = __importDefault(require("chokidar"));
const express_1 = __importDefault(require("express"));
const cors_1 = __importDefault(require("cors"));
const variables_1 = require("./variables");
const nodeJsBundler_1 = require("./bundlers/javascript/nodeJsBundler");
const nodeTsBundler_1 = require("./bundlers/typescript/nodeTsBundler");
const loglevel_1 = __importDefault(require("loglevel"));
const file_1 = require("./utils/file");
const process_1 = require("process");
const body_parser_1 = __importDefault(require("body-parser"));
const url_1 = __importDefault(require("url"));
const genezioRequestParser_1 = require("./utils/genezioRequestParser");
const logging_1 = require("./utils/logging");
const projectConfiguration_1 = require("./models/projectConfiguration");
const node_cron_1 = __importDefault(require("node-cron"));
const generateSdk_1 = __importDefault(require("./requests/generateSdk"));
const commands_1 = require("./commands");
const configuration_1 = require("./utils/configuration");
const sdk_1 = require("./utils/sdk");
function getEventObjectFromRequest(request) {
    var _a;
    const urlDetails = url_1.default.parse(request.url, true);
    return {
        headers: request.headers,
        rawQueryString: urlDetails.search ? (_a = urlDetails.search) === null || _a === void 0 ? void 0 : _a.slice(1) : "",
        queryStringParameters: urlDetails.search
            ? Object.assign({}, urlDetails.query)
            : undefined,
        timeEpoch: Date.now(),
        body: request.body,
        isBase64Encoded: request.isBase64Encoded,
        requestContext: {
            http: {
                method: request.method,
                path: urlDetails.pathname,
                protocol: request.httpVersion,
                sourceIp: request.socket.remoteAddress,
                userAgent: request.headers["user-agent"]
            }
        }
    };
}
exports.getEventObjectFromRequest = getEventObjectFromRequest;
function handleResponseForJsonRpc(res, jsonRpcResponse) {
    res.setHeader("Content-Type", "application/json");
    res.end(JSON.stringify(jsonRpcResponse));
}
exports.handleResponseForJsonRpc = handleResponseForJsonRpc;
function handleResponseforHttp(res, httpResponse) {
    if (httpResponse.statusDescription) {
        res.statusMessage = httpResponse.statusDescription;
    }
    let contentTypeHeader = false;
    if (httpResponse.headers) {
        for (const header of Object.keys(httpResponse.headers)) {
            res.setHeader(header.toLowerCase(), httpResponse.headers[header]);
            if (header.toLowerCase() === "content-type") {
                contentTypeHeader = httpResponse.headers[header];
            }
        }
    }
    if (!contentTypeHeader) {
        res.setHeader("content-type", "application/json");
    }
    if (httpResponse.statusCode) {
        res.writeHead(parseInt(httpResponse.statusCode));
    }
    if (httpResponse.isBase64Encoded === true) {
        res.end(Buffer.from(httpResponse.body, "base64"));
    }
    else {
        if (Buffer.isBuffer(httpResponse.body)) {
            res.end(JSON.stringify(httpResponse.body.toJSON()));
        }
        else {
            res.end(httpResponse.body ? httpResponse.body : "");
        }
    }
}
exports.handleResponseforHttp = handleResponseforHttp;
function listenForChanges(sdkPathRelative, server, cronHandlers) {
    return __awaiter(this, void 0, void 0, function* () {
        const cwd = process.cwd();
        let sdkPath = null;
        if (sdkPathRelative) {
            sdkPath = path_1.default.join(cwd, sdkPathRelative);
        }
        let ignoredPathsFromGenezioIgnore = [];
        // check for .genezioignore file
        const ignoreFilePath = path_1.default.join(cwd, ".genezioignore");
        if (yield (0, file_1.fileExists)(ignoreFilePath)) {
            // read the file as a string
            const ignoreFile = yield (0, file_1.readUTF8File)(ignoreFilePath);
            // split the string by new line \n
            const ignoreFileLines = ignoreFile.split("\n");
            // remove empty lines
            const ignoreFileLinesWithoutEmptyLines = ignoreFileLines.filter((line) => line !== "" && !line.startsWith("#"));
            ignoredPathsFromGenezioIgnore = ignoreFileLinesWithoutEmptyLines.map((line) => {
                if (line.startsWith("/")) {
                    return line;
                }
                return path_1.default.join(cwd, line);
            });
        }
        return new Promise((resolve) => {
            // delete / if sdkPath ends with /
            if (sdkPath === null || sdkPath === void 0 ? void 0 : sdkPath.endsWith("/")) {
                sdkPath = sdkPath.slice(0, -1);
            }
            // Watch for changes in the classes and update the handlers
            const watchPaths = [path_1.default.join(cwd, "/**/*")];
            let ignoredPaths = [];
            if (sdkPath) {
                ignoredPaths = [
                    "**/node_modules/*",
                    // "**/node_modules/**/*",
                    sdkPath + "/**/*",
                    sdkPath + "/*",
                    ...ignoredPathsFromGenezioIgnore
                ];
            }
            else {
                ignoredPaths = ["**/node_modules/*", ...ignoredPathsFromGenezioIgnore];
            }
            const startWatching = () => {
                const watch = chokidar_1.default
                    .watch(watchPaths, {
                    ignored: ignoredPaths,
                    ignoreInitial: true
                })
                    .on("all", (event, path) => __awaiter(this, void 0, void 0, function* () {
                    if (sdkPath) {
                        if (path.includes(sdkPath)) {
                            return;
                        }
                    }
                    console.clear();
                    loglevel_1.default.info("\x1b[36m%s\x1b[0m", "Change detected, reloading...");
                    if (server && cronHandlers) {
                        // removed await for now for faster reloads
                        server.close();
                        stopCronJobs(cronHandlers);
                    }
                    watch.close();
                    resolve({});
                }));
            };
            startWatching();
        });
    });
}
exports.listenForChanges = listenForChanges;
function stopCronJobs(cronHandlers) {
    return __awaiter(this, void 0, void 0, function* () {
        for (const cronHandler of cronHandlers) {
            if (cronHandler.cronObject) {
                yield cronHandler.cronObject.stop();
            }
        }
    });
}
exports.stopCronJobs = stopCronJobs;
function prepareCronHandlers(classesInfo, handlers) {
    return __awaiter(this, void 0, void 0, function* () {
        const cronHandlers = [];
        for (const classElement of classesInfo) {
            const methods = classElement.methods;
            for (const method of methods) {
                if (method.type === "cron" && method.cronString) {
                    const cronHandler = {
                        className: classElement.className,
                        methodName: method.name,
                        cronString: method.cronString,
                        path: handlers[classElement.className].path,
                        cronObject: null,
                        module: handlers[classElement.className].module
                    };
                    cronHandlers.push(cronHandler);
                }
            }
        }
        return cronHandlers;
    });
}
exports.prepareCronHandlers = prepareCronHandlers;
function startCronHandlers(cronHandlers) {
    return __awaiter(this, void 0, void 0, function* () {
        // create cron objects
        for (const cronHandler of cronHandlers) {
            cronHandler.cronObject = node_cron_1.default.schedule(cronHandler.cronString, () => __awaiter(this, void 0, void 0, function* () {
                const reqToFunction = {
                    genezioEventType: "cron",
                    methodName: cronHandler.methodName,
                    cronString: cronHandler.cronString
                };
                const module = cronHandler.module;
                yield module.handler(reqToFunction);
            }));
        }
        // start cron jobs
        for (const cronHandler of cronHandlers) {
            cronHandler.cronObject.start();
        }
        return cronHandlers;
    });
}
exports.startCronHandlers = startCronHandlers;
function startLocalTesting(classesInfo, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const projectConfiguration = yield (0, configuration_1.getProjectConfiguration)();
        if (projectConfiguration.classes.length === 0) {
            throw new Error("No classes found in genezio.yaml");
        }
        let astSummary = undefined;
        const sdk = yield (0, generateSdk_1.default)(projectConfiguration);
        astSummary = sdk.astSummary;
        const localEnvInfo = yield prepareForLocalEnvironment(projectConfiguration, sdk.astSummary, Number(options.port), classesInfo);
        classesInfo = localEnvInfo.classesInfo;
        const handlers = localEnvInfo.handlers;
        yield (0, sdk_1.replaceUrlsInSdk)(sdk, sdk.classFiles.map((c) => ({ name: c.name, cloudUrl: `http://127.0.0.1:${options.port}/${c.name}` })));
        yield (0, sdk_1.writeSdkToDisk)(sdk, projectConfiguration.sdk.language, projectConfiguration.sdk.path);
        (0, commands_1.reportSuccess)(classesInfo, sdk);
        return ({
            handlers,
            classesInfo,
            astSummary
        });
    });
}
exports.startLocalTesting = startLocalTesting;
function startServer(classesInfo, handlers, astSummary, port = variables_1.PORT_LOCAL_ENVIRONMENT) {
    return __awaiter(this, void 0, void 0, function* () {
        const app = (0, express_1.default)();
        app.use((0, cors_1.default)());
        app.use(body_parser_1.default.raw({ type: () => true }));
        app.use(genezioRequestParser_1.genezioRequestParser);
        let cronHandlers = yield prepareCronHandlers(classesInfo, handlers);
        cronHandlers = yield startCronHandlers(cronHandlers);
        app.get("/get-ast-summary", (req, res) => {
            res.setHeader("Content-Type", "application/json");
            res.end(JSON.stringify(astSummary));
        });
        app.all(`/:className`, (req, res) => __awaiter(this, void 0, void 0, function* () {
            const reqToFunction = getEventObjectFromRequest(req);
            const localHandler = handlers[req.params.className];
            if (!localHandler) {
                res.status(404).send("Not found");
                return;
            }
            logging_1.debugLogger.debug(`Request received for ${req.params.className}.`);
            const module = localHandler.module;
            const response = yield module.handler(reqToFunction);
            handleResponseForJsonRpc(res, response);
        }));
        app.all(`/:className/:methodName`, (req, res) => __awaiter(this, void 0, void 0, function* () {
            const reqToFunction = getEventObjectFromRequest(req);
            logging_1.debugLogger.debug(`HTTP Request received ${req.method} ${req.url}.`);
            const handler = handlers[req.params.className];
            if (!handler) {
                loglevel_1.default.error(`Could not find class ${req.params.className}. The path should be /<class_name>/<method_name>`);
                res.set("Content-Type", "application/json");
                res.writeHead(404);
                res.end(JSON.stringify({ error: `Class not found ${req.params.className}.` }));
                return;
            }
            const module = handler.module;
            const response = yield module.handler(reqToFunction);
            handleResponseforHttp(res, response);
        }));
        const server = app.listen(port, () => {
            loglevel_1.default.info(`Server listening on port ${port}`);
        });
        return {
            cronHandlers,
            server: server
        };
    });
}
exports.startServer = startServer;
function prepareForLocalEnvironment(yamlProjectConfiguration, astSummary, port = variables_1.PORT_LOCAL_ENVIRONMENT, classesInfoInput) {
    return __awaiter(this, void 0, void 0, function* () {
        const functionUrlForFilePath = {};
        const handlers = {};
        const classesInfo = [];
        const projectConfiguration = new projectConfiguration_1.ProjectConfiguration(yamlProjectConfiguration, astSummary);
        const promises = projectConfiguration.classes.map((element) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (!(yield (0, file_1.fileExists)(element.path))) {
                loglevel_1.default.error(`\`${element.path}\` file does not exist at the indicated path.`);
                (0, process_1.exit)(1);
            }
            const astClassSummary = astSummary.classes.find((c) => c.path === element.path);
            if (!astClassSummary) {
                logging_1.debugLogger.debug(`Could not find astClassSummary for element ${element}`);
                return Promise.resolve();
            }
            let bundler;
            switch (element.language) {
                case ".ts": {
                    bundler = new nodeTsBundler_1.NodeTsBundler();
                    break;
                }
                case ".js": {
                    bundler = new nodeJsBundler_1.NodeJsBundler();
                    break;
                }
                default: {
                    loglevel_1.default.error(`Unsupported language ${element.language}. Skipping class ${element.path}`);
                    return Promise.resolve();
                }
            }
            logging_1.debugLogger.debug(`The bundling process has started for file ${element.path}...`);
            const tmpFolder = ((_a = classesInfoInput.find((c) => c.path === element.path)) === null || _a === void 0 ? void 0 : _a.tmpFolder) || (yield (0, file_1.createTemporaryFolder)());
            return bundler
                .bundle({
                configuration: element,
                path: element.path,
                extra: { mode: "development", tmpFolder: tmpFolder }
            })
                .then((output) => {
                logging_1.debugLogger.debug("The bundling process finished successfully.");
                const className = astClassSummary.name;
                const handlerPath = path_1.default.join(output.path, "index.js");
                const baseurl = `http://127.0.0.1:${port}/`;
                const functionUrl = `${baseurl}${className}`;
                functionUrlForFilePath[path_1.default.parse(element.path).name] = functionUrl;
                const methods = (astClassSummary === null || astClassSummary === void 0 ? void 0 : astClassSummary.methods.map((m) => {
                    var _a;
                    return Object.assign(Object.assign({}, m), { cronString: ((_a = element.methods.find((e) => e.name === m.name)) === null || _a === void 0 ? void 0 : _a.cronString) || null });
                })) || [];
                classesInfo.push({
                    className: className,
                    methods: methods,
                    path: element.path,
                    functionUrl: baseurl,
                    tmpFolder: tmpFolder
                });
                // eslint-disable-next-line @typescript-eslint/no-var-requires
                delete require.cache[require.resolve(handlerPath)];
                delete require.cache[require.resolve(path_1.default.join(path_1.default.dirname(handlerPath), "module.js"))];
                handlers[className] = {
                    path: handlerPath,
                    module: require(handlerPath)
                };
            });
        }));
        yield Promise.all(promises);
        return {
            functionUrlForFilePath,
            handlers,
            classesInfo
        };
    });
}
exports.prepareForLocalEnvironment = prepareForLocalEnvironment;
