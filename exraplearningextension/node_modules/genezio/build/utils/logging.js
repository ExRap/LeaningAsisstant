"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.printUninformativeLog = exports.printAdaptiveLog = exports.setDebuggingLoggerLogLevel = exports.debugLogger = exports.spinner = void 0;
const loglevel_1 = __importDefault(require("loglevel"));
const cli_spinner_1 = require("cli-spinner");
// eslint-disable-next-line @typescript-eslint/no-var-requires
const terminalOverwrite = require('terminal-overwrite');
exports.spinner = new cli_spinner_1.Spinner("%s  ");
exports.spinner.setSpinnerString("|/-\\");
exports.debugLogger = loglevel_1.default.getLogger("debuggingLogger");
function setDebuggingLoggerLogLevel(logLevel) {
    if (!logLevel)
        return;
    exports.debugLogger.setLevel(logLevel);
}
exports.setDebuggingLoggerLogLevel = setDebuggingLoggerLogLevel;
function printAdaptiveLog(message, state) {
    if (state == "end") {
        exports.spinner.stop(true);
        terminalOverwrite(message + "...✅");
        loglevel_1.default.info("");
    }
    else if (state == "start") {
        terminalOverwrite(message + "...");
        exports.spinner.start();
    }
    else {
        exports.spinner.stop(true);
        terminalOverwrite(message + "...❌");
        loglevel_1.default.info("");
    }
}
exports.printAdaptiveLog = printAdaptiveLog;
const uninformativeMessages = [
    "Calling the API for witty loading messages",
    "Asking on StackOverflow how to deploy your project",
    "Changing the plumbing of the pipeline",
    "Rearranging the code randomly",
    "Calling the mothership for further instructions",
    "Deploying...crossing our fingers",
    "Doing a barrel roll",
    "*playing elevator music*",
    "Spraying your code with bug repellents",
    "Baking a cake",
    "Changing spaces to tabs"
];
const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));
function printUninformativeLog(controller) {
    return __awaiter(this, void 0, void 0, function* () {
        const finalMessage = "Doing the final touch-ups";
        const message = uninformativeMessages[Math.floor(Math.random() * uninformativeMessages.length)];
        let exitLoop = false;
        let waiting = 0;
        let spinning = true;
        let firstMessage = false;
        controller.signal.addEventListener('abort', () => {
            exitLoop = true;
        });
        exports.spinner.start();
        while (!exitLoop) {
            yield delay(250);
            waiting += 250;
            if (waiting == 5000) {
                exports.spinner.stop(true);
                spinning = false;
                printAdaptiveLog(message, "start");
                firstMessage = true;
            }
            if (waiting == 15000) {
                printAdaptiveLog(message, "end");
                firstMessage = false;
                printAdaptiveLog(finalMessage, "start");
            }
        }
        if (spinning) {
            exports.spinner.stop(true);
            printAdaptiveLog(finalMessage, "start");
            return finalMessage;
        }
        if (firstMessage) {
            return message;
        }
        else {
            return finalMessage;
        }
    });
}
exports.printUninformativeLog = printUninformativeLog;
