"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateYamlFile = exports.checkYamlFileExists = exports.writeToFile = exports.readUTF8File = exports.getFileDetails = exports.createTemporaryFolder = exports.fileExists = exports.zipDirectoryToDestinationPath = exports.zipDirectory = exports.getAllFilesFromCurrentPath = void 0;
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const fileDetails_1 = __importDefault(require("../models/fileDetails"));
const glob_1 = __importDefault(require("glob"));
const archiver_1 = __importDefault(require("archiver"));
const yaml_1 = require("yaml");
const process_1 = require("process");
const aws_cron_parser_1 = __importDefault(require("aws-cron-parser"));
const loglevel_1 = __importDefault(require("loglevel"));
function getAllFilesFromCurrentPath() {
    return __awaiter(this, void 0, void 0, function* () {
        // get genezioIgnore file
        let genezioIgnore = [];
        const genezioIgnorePath = path_1.default.join(process.cwd(), ".genezioignore");
        if (fs_1.default.existsSync(genezioIgnorePath)) {
            const genezioIgnoreContent = yield readUTF8File(genezioIgnorePath);
            genezioIgnore = genezioIgnoreContent.split("\n").filter((line) => line !== "" && !line.startsWith("#"));
        }
        return new Promise((resolve, reject) => {
            (0, glob_1.default)(`./**/*`, {
                dot: true,
                ignore: genezioIgnore
            }, (err, files) => {
                if (err) {
                    reject(err);
                }
                const fileDetails = files.map((file) => {
                    return {
                        name: path_1.default.parse(file).name,
                        extension: path_1.default.parse(file).ext,
                        path: file,
                        filename: file
                    };
                });
                resolve(fileDetails);
            });
        });
    });
}
exports.getAllFilesFromCurrentPath = getAllFilesFromCurrentPath;
function zipDirectory(sourceDir, outPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const archive = (0, archiver_1.default)("zip", { zlib: { level: 9 } });
        const stream = fs_1.default.createWriteStream(outPath);
        return new Promise((resolve, reject) => {
            archive
                .directory(sourceDir, false)
                .on("error", (err) => reject(err))
                .pipe(stream);
            stream.on("close", () => resolve());
            archive.finalize();
        });
    });
}
exports.zipDirectory = zipDirectory;
function zipDirectoryToDestinationPath(sourceDir, destinationPath, outPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const archive = (0, archiver_1.default)("zip", { zlib: { level: 9 } });
        const stream = fs_1.default.createWriteStream(outPath);
        return new Promise((resolve, reject) => {
            archive
                .directory(sourceDir, destinationPath)
                .on("error", (err) => reject(err))
                .pipe(stream);
            stream.on("close", () => resolve());
            archive.finalize();
        });
    });
}
exports.zipDirectoryToDestinationPath = zipDirectoryToDestinationPath;
function fileExists(filePath) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve) => {
            fs_1.default.stat(filePath, (exists) => {
                if (exists == null) {
                    return resolve(true);
                }
                else if (exists.code === "ENOENT") {
                    return resolve(false);
                }
            });
        });
    });
}
exports.fileExists = fileExists;
function createTemporaryFolder(name = "foo-") {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            fs_1.default.mkdtemp(path_1.default.join(os_1.default.tmpdir(), name), (error, folder) => {
                if (error) {
                    reject(error);
                }
                resolve(folder);
            });
        });
    });
}
exports.createTemporaryFolder = createTemporaryFolder;
function getFileDetails(filePath) {
    const { ext, name, dir, base } = path_1.default.parse(filePath);
    return new fileDetails_1.default(name, ext, dir, base);
}
exports.getFileDetails = getFileDetails;
function readUTF8File(filePath) {
    return new Promise((resolve, reject) => {
        fs_1.default.readFile(filePath, "utf8", function (error, data) {
            if (error) {
                reject(error);
            }
            resolve(data);
        });
    });
}
exports.readUTF8File = readUTF8File;
function writeToFile(folderPath, filename, content, createPathIfNeeded = false) {
    return new Promise((resolve, reject) => {
        if (!fs_1.default.existsSync(folderPath) && createPathIfNeeded) {
            fs_1.default.mkdirSync(folderPath, { recursive: true });
        }
        // create the file if it doesn't exist
        fs_1.default.writeFile(path_1.default.join(folderPath, filename), content, function (error) {
            if (error) {
                reject(error);
                return;
            }
            resolve();
        });
    });
}
exports.writeToFile = writeToFile;
function checkYamlFileExists(yamlPath = "./genezio.yaml") {
    return __awaiter(this, void 0, void 0, function* () {
        if (!(yield fileExists(yamlPath))) {
            loglevel_1.default.error("genezio.yaml file does not exist. Please run `genezio init` to initialize a project.");
            return false;
        }
        return true;
    });
}
exports.checkYamlFileExists = checkYamlFileExists;
function validateYamlFile() {
    return __awaiter(this, void 0, void 0, function* () {
        const configurationFileContentUTF8 = yield readUTF8File("./genezio.yaml");
        let configurationFileContent = null;
        try {
            configurationFileContent = yield (0, yaml_1.parse)(configurationFileContentUTF8);
        }
        catch (error) {
            throw new Error(`The configuration yaml file is not valid.\n${error}`);
        }
        if (configurationFileContent.classes.length === 0) {
            loglevel_1.default.info("You don't have any classes in your genezio.yaml file. You can add classes using the 'genezio addClass <className> <classType>' command.");
            (0, process_1.exit)(1);
        }
        for (const elem of configurationFileContent.classes) {
            if (elem.methods === undefined) {
                continue;
            }
            for (const method of elem.methods) {
                if (method.type === "cron") {
                    if (method.cronString === undefined) {
                        loglevel_1.default.warn(`You need to specify a cronString for the method ${elem.path}.${method.name}.`);
                        (0, process_1.exit)(1);
                    }
                    else {
                        try {
                            const cron = aws_cron_parser_1.default.parse(method.cronString);
                        }
                        catch (error) {
                            loglevel_1.default.error(`The cronString ${method.cronString} for the method ${elem.path}.${method.name} is not valid.`);
                            loglevel_1.default.error("You must use a 6-part cron expression.");
                            loglevel_1.default.error(error.toString());
                            (0, process_1.exit)(1);
                        }
                    }
                }
            }
        }
    });
}
exports.validateYamlFile = validateYamlFile;
